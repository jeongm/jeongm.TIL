## 복잡도
프로그램의 실행 속도(또는 실행하는 데 필요한 시간)는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라진다.   
알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity)라고 하며 복잡도는 다음과 같이 2가지로 구분함
```
- 시간 복잡도 : 실행하는 데 필요한 시간을 평가
- 공간 복잡도 : 메모리(기억 공간)와 파일 공간이 얼마나 필요한지를 평가
```

## 시간 복잡도(Time complexity)
- 자료의 수 n이 증가할 때 시간이 증가하는 대략적인 패턴으로 이를  Big-O 표기법(Big O notation)으로 주로 나타냄
- 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것
> 기본적인 연산이란 더 작게 쪼갤 수 없는 최소 크기의 연산
- 시간 복잡도가 높다는 말은 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다는 의미
> 시간 복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아님
- 예를 들어 입력 자료의 크기 n에 대하여 O(n)의 시간복잡도를 가진 알고리즘은 대략 크기 n에 비례하는 수의 연산을 수행한다고 보면 됨
- 검색 알고리즘의 경우 O(1)이나 O(logn)의 시간복잡도를 가지는 알고리즘을 선호 ex)해시
- 정렬 알고리즘의 경우 O(nlogn)의 시간복잡도를 가지는 알고리즘을 선호함 ex)퀵
> 가장 깊이 중첩된 반복문의 내부에 있는 기본적인 연산들은 더 쪼갤 수 없기 때문에, 이것이 시간 복잡도의 대략적인 기준이 됨
> 입력이 어떤 형태로 구성되어 있는지도 수행 시간에 영향을 미침

 ## 알고리즘 시간 복잡도 표기법
- 최상의 경우 : 오메가 표기법 (Big-Ω Notation)
- 최악의 경우 : 빅오 표기법 (Big-O Notation)   
  가장 보편적으로 사용됨, Big-O 표기법은 계수와 낮은 차수의 항을 제외시키는 방법임(ex: 2n²-2n+2 > O(n2)로 표기). 
- 평균의 경우 : 세타 표기법 (Big-θ Notation)

### 대표적인 시간 복잡도 
- O(1) – 상수 시간 : 입력값 n 이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거칩니다.(constant time)   
  값을 검색할 때, 객체에서 key를 알거나 배열에서 index를 알고 있으면 언제나 한 단계만 거침
- O(log n) – 로그 시간 : 입력값 n 이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듭니다.(log time)   
  n의 개수가 늘어나면, n이 늘어난 개수보다 조금 더 연산량이 증가하고 2배를 넘지 않는다   
  배열에서 값을 찾을 때 어느 쪽에서 시작할지를  알고 있으면 검색하는 시간이 두 배로 줄어든다.   
- O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가집니다. (linear time)   
- O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱입니다. (quadratic time)   
  중복된 반복문을 사용했을 때 걸리는 시간을 의미함   
  n의 개수의 최악 n^2연산량을 요구함
- O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱입니다.(exponential time)   
  보통 문제를 풀기 위해 모든 조합과 방법을 시도할 때 사용됨   
  ex)길이가 n인 비밀번호를 찾아야 할 경우   
![timecomplexity1](https://joshuajangblog.files.wordpress.com/2016/09/1.jpg?w=638)
![timecomplexity2](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9941F43B5ABDBF4E1F)

### 분할 상환 분석
- N개의 작은 작업들을 순서대로 하는데, 각 작업에 걸리는 시간은 모두 다르지만 전체 작업에 걸리는 시간이 일정한 경우 적용할 수 있음
- 이때 각 작업에 걸리는 평균 시간은 전체 시간을 작업의 개수로 나눈 것과 같다고 할 수 있다.
