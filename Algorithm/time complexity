시간 복잡도(Time complexity)
 : 자료의 수 n이 증가할 때 시간이 증가하는 대략적인 패턴으로 이를  Big-O 표기법(Big O notation)으로 주로 나타냄
예를 들어 입력 자료의 크기 n에 대하여 O(n)의 시간복잡도를 가진 알고리즘은 대략 크기 n에 비례하는 수의 연산을 수행한다고 보면 됨
검색 알고리즘의 경우 O(1)이나 O(logn)의 시간복잡도를 가지는 알고리즘을 선호 ex)해시
정렬 알고리즘의 경우 O(nlogn)의 시간복잡도를 가지는 알고리즘을 선호함 ex)퀵


 알고리즘 시간 복잡도 표기법
- 최상의 경우 : 오메가 표기법 (Big-Ω Notation)
- 최악의 경우 : 빅오 표기법 (Big-O Notation)
 가장 보편적으로 사용됨, Big-O 표기법은 계수와 낮은 차수의 항을 제외시키는 방법임(ex: 2n²-2n+2 > O(n2)로 표기). 
- 평균의 경우 : 세타 표기법 (Big-θ Notation)
- 대표적인 시간 복잡도 
O(1) – 상수 시간 : 입력값 n 이 주어졌을 때, 알고리즘이 문제를 해결하는데 오직 한 단계만 거칩니다.(constant time)
  값을 검색할 때, 객체에서 key를 알거나 배열에서 index를 알고 있으면 언제나 한 단계만 거침
O(log n) – 로그 시간 : 입력값 n 이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듭니다.(log time)
  n의 개수가 늘어나면, n이 늘어난 개수보다 조금 더 연산량이 증가하고 2배를 넘지 않는다
  배열에서 값을 찾을 때 어느 쪽에서 시작할지를  알고 있으면 검색하는 시간이 두 배로 줄어든다.
O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가집니다. (linear time)
O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱입니다. (quadratic time)
  중복된 반복문을 사용했을 때 걸리는 시간을 의미함
  n의 개수의 최악 n^2연산량을 요구함
O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱입니다.(exponential time)
  보통 문제를 풀기 위해 모든 조합과 방법ㅇ르 시도할 때 사용됨
  ex)길이가 n인 비밀번호를 찾아야 할 경우
